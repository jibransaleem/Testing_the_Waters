# -*- coding: utf-8 -*-
"""OOP2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B7OnEci4DjHVC5mQU5lfbBlgvAEiy0k2
"""

class Fraction:
   def __init__(self,deno,nem):
      self.deno = deno
      self.nem = nem
   def __add__(self,other):
      ans  = round( ((self.deno*other.nem )+( other.deno*self.nem)) / (self.nem * other.nem))
      print(ans)
   def __mul__(self,other):
      ans  =(self.deno*other.deno) / (self.nem*other.nem)
      print(ans)

"""Varibles created with self are called instance variable

**ENCAPSULATION**

**ACCESS MODIFIERS:**

Access modifiers are keywords used in Object-Oriented Programming (OOP) to control the visibility or accessibility of class members (like variables, methods, and constructors). They define who can access specific parts of a class.

# **OR**

Access modifiers in Object-Oriented Programming (OOP) define the visibility and accessibility of class members (variables, methods, etc.) in a program. In simple terms, they control who can use or see a particular member of a class.



## **Types of Access Modifiers**

 In Python, private, protected, and public access modifiers work the same way for both data (attributes) and methods (functions). These modifiers apply to both variables and methods to control how they are accessed within and outside the class.

# **Public (public):**

Accessible everywhere in the program.

No restrictions.

Example: Open to all!

Any attribute or method without an underscore prefix is public.
Accessible from anywhere (inside or outside the class).


# **Private (private):**

Accessible only within the same class.

Not accessible to other classes or objects.

Example: For personal use only.

Attributes or methods with a double underscore prefix are private.

They are name-mangled to make them harder to access directly from outside the class.

example : **self.__privatevar = None:**

# **Protected (protected):**

Accessible within the same class and by subclasses (child classes).

Example: For family use (parent and child classes).

Attributes or methods with a single underscore prefix are protected by convention.


Meant to be used within the class and its subclasses.
Not enforced, just a signal to developers.

example: self._proctected_var = None
**bold text**
# **Default (no keyword in many languages):**

Accessible within the same package (for languages like Java).

Example: For neighborhood use (package level).

Internally the private var or method is broken as :

Classname+accessmodifer method/var thats why you cant acees them by name directly as their name is modified internally , you may acess this by their class name known as NAME MANGLING
"""

class Private:
  def __init__(self,a,b):
    self.__a = a
    self.__b = b
  def show(self):
    print(self.__a,self.__b)
obj  = Private(10,20)
obj._Private__a # Name mangling , aceesing private data

class PrivateMethod:
  def __init__(self,a,b):
     self.__a = a
     self.__b = b
  def __Private_method(self):
      print('You have acees this privte method')

obj  = Private(10,20)
obj._PrivateMethod__Private_method()#'Private' object has no attribute '_PrivateMethod__Private_method'

"""# **Getter and Setter:**

getter() = > To display the private/protocted var values

setter() = > To change the private/protected var values

QUESTION:

If we can change the value of private/protected var directlt using name mangling so why setter method , acessing using name mangling is very non serious first , even we try to acess it and if our new given data type does not matches the desired need data type of that var so code can break or any error , so for this we use setter method where we can write our own logic to handle these data mis match or any issues
"""

#Class which give number with addition of 10
class Example:
  def __init__(self,a):
     self.__a = a

  def getter(self):
    print(f"Value of a {self.__a+10} ")

  def setter(self,val):
    if type(val)!=type(self.__a):
      print("Invalid data type")
    else:
      self.__a = val


obj = Example(1)
obj.getter()
obj.setter(10)
obj.getter()

